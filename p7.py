"""
小蓝对一个数的数位之和很感兴趣，今天他要按照数位之和给数排序。当两个数各个数位之和不同时，将数位和较小的排在前面，当数位之和相等时，将数值小的排在前面。

例如，2022 排在 409 前面，因为 2022 的数位之和是 6，小于 409 的数位之和 13。

又如，6 排在 2022 前面，因为它们的数位之和相同，而 6 小于 2022。

给定正整数 n，m，请问对 1 到 n 采用这种方法排序时，排在第 m 个的元素是多少？ 
输入格式
输入第一行包含一个正整数 n。

第二行包含一个正整数 m。
输出格式
输出一行包含一个整数，表示答案。
样例输入
13
5
样例输出
3
提示
1 到 13 的排序为：1, 10, 2, 11, 3, 12, 4, 13, 5, 6, 7, 8, 9。第 5 个数为 3。

对于 30% 的评测用例，1 ≤ m ≤ n ≤ 300。

对于 50% 的评测用例，1 ≤ m ≤ n ≤ 1000。

对于所有评测用例，1 ≤ m ≤ n ≤ 106。
"""

def f(n):
    digit_sum=[0]*(n+1)
    for i in range(1,n+1):
        # 动态规划法DP,
        # 通过已经计算过的较小数的数位之和来计算较大数的数位之和，从而避免重复计算。
        digit_sum[i] = digit_sum[i//10] + (i%10)    #牛逼！！！
    return digit_sum

def f_sort(m):
    digit_sum = f(n)
    groups = [[] for _ in range(55)]

    for i in range(1,n+1):
        s = digit_sum[i]
        groups[s].append(i)

    c=0
    for i in range(1,55):
        for num in groups[i]:
            c+=1
            if c==m:
                return num
n=int(input())
m=int(input())
print(f_sort(m))
